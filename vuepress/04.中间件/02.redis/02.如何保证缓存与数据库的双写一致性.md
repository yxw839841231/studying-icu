---
title: 如何保证缓存与数据库的双写一致性
date: 2021-01-04 17:56:49
permalink: /pages/37029c/
categories:
  - 中间件
  - redis
tags:
  - 
---
# 如何保证缓存与数据库的双写一致性

之所以提到这个问题，是因为你只要用缓存，就可能会涉及到缓存与数据库双存储双写，既然是双写，就一定会有数据一致性的问题，那么如何解决一致性问题？

## Cache Aside Pattern

Cache Aside Pattern 是最为经典的缓存+数据库读写模式：
- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

### 为什么是删除而不是更新
- 1、删除比更新更高效
- 2、删除比更新更合理

关于第一点，很好理解，毕竟更新你需要做一系列处理。
关于第二点，实际上是因为，有些时候，缓存的并不是单一数据库对象，比如你缓存了一个商品信息，商品基本信息和扩展信息不在一个表，如果只是改了扩展信息，那你要针对缓存的扩展信息进行修改，很麻烦。
还有就是缓存的信息可能进过二次转换处理，解析或者格式化，如果去更新，容易出现问题。

### 为什么是删除后更新

因为，如果先更新数据库成功，后删除缓存失败，在这种情况下，缓存的是旧值，而数据库已经更新成功，两者数据不一致；而如果是先删除后更新，即便删除成功更新失败，因为缓存为空，依然能取到数据库的值，至少能保证数据一致性。


## 新的问题

上文提到了更新的时候，先删除后更新能保证数据一致性。这种说法不完全准确。举个例子：
```
请求A来更新数据库，先删除缓存成功了，此时请求B来查询数据，查询到了数据库的值，然后请求A继续更新数据库成功了。在这种情况下，是会导致数据库和缓存是不一致的。
```

### 如何解决

简单一点来说，可以根据数据标识来决定是否强制更新缓存。当数据库更新成功后，可以在内存队列中存下该记录的唯一标识。查询操作到来的时候，匹配缓存数据的标识和该内存的数据标识，如果不一致，则删除缓存重新查询数据。
但是需要注意的是，在表记录会显著存在大量更新的情况下，这种方案并不合适，反而会加重数据库的负担。


<Vssue  />