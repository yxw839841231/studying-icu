---
title: Java锁之自旋锁
date: 2021-01-14 16:40:59
permalink: /pages/6649c3/
categories:
tags:
  - 锁
---
# Java锁之自旋锁

## 原理

如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋）， 
等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程 也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。

如果持有锁的线程执行的时间超过自旋等待的最大时间仍然没有释放锁，就会导致其它争用锁 的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。

## 优缺点

自旋锁尽可能的减少线程的阻塞，这对于锁的**竞争不激烈**，且**占用锁时间非常短**的代码块来
说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会
导致线程发生两次上下文切换！

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合
使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，
其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。

## 自旋锁时间阈值

因为自旋锁为了更快的获取到锁，而一直占用CPU，直到获取锁或者超过自旋时间，所以需要确定一个合理的自旋时间。

jdk1.5中，JVM 对于自旋周期的限制是写死的，在 jdk1.6 引入了**适应性自旋锁**，也就意味着自旋的时间不在是固定的了。
而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当
前 CPU 的负荷情况做了较多的优化：
- 如果平均负载小于 CPUs 则一直自旋；
- 如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞；
- 如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞；
- 如果 CPU 处于节电模式则停止自旋；
  
自旋时间的最坏情况是 CPU 的 **内存延迟**，自旋时会适当放弃线程优先级之间的差异。

<Vssue  />