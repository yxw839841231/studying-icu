---
title: Java锁之一些锁概念
date: 2021-01-16 19:31:34
permalink: /pages/fc7330/
categories:
tags:
  - 锁
---

# Java锁之一些锁概念

关于 Java 中的锁，有一些有具体的实现，有一些则是一种思想。

<!-- more -->

## 公平锁与非公平锁

### 公平锁 （Fair）
加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。

### 非公平锁（Nonfair）

加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待：

- 非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列；
- Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。

## ReadWriteLock 读写锁

为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制。
在没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。
读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。

### 读锁

如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁。

### 写锁
如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。

>Java 提供了读写锁接口 java.util.concurrent.locks.ReadWriteLock，ReentrantReadWriteLock 是一种具体实现。

## 共享锁和独占锁
java 并发包提供的加锁模式分为独占锁和共享锁。

### 独占锁
   独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。
   独占锁是一种悲观保守的加锁策略，避免了读/读冲突，如果某个只读线程获取锁，则其他读线
   程都只能等待，这种情况下就限制了不必要的并发，因为读操作不会影响数据的一致性。
   
### 共享锁
   共享锁则允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。
   共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。
   
- AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。
- Java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。

## 重量级锁（Mutex Lock）

Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。
但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。
而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，
这就是为什么Synchronized 效率低的原因。
因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为**重量级锁**。

jdk 中对 Synchronized 做的各种优化，其核心目的都是为了减少这种重量级锁的使用。
jdk1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了**轻量级锁**和**偏向锁**。


## 轻量级锁

锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。

### 锁升级

随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。

> `轻量级` 是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，
轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。
>
>在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，
如果存在同一时间访问同一锁的情况，就会导致轻量级锁 `膨胀` 为重量级锁。


## 偏向锁

偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。

引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，
而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，
所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。

上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。

## 分段锁

分段锁并非一种实际的锁，而是一种思想。最被我们熟悉的是 ConcurrentHashMap 中的具体实现。

## 同步锁

当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。
Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。

## 死锁

所谓死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。

比如：线程A持有对象b的锁，等待获取对象a的锁；线程B持有对象a的锁，同时又在等待获取对象b的锁。
这种情形下，线程A和线程B在互相等待，永远无法获取对方持有的锁，同时又不是释放已经持有的锁，就形成了死锁。

<Vssue />