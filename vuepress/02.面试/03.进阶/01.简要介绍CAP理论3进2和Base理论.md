---
title: 简要介绍CAP理论3进2和Base理论
date: 2020-11-11 14:27
permalink: /pages/80fa73/
categories:
  - 面试
  - 进阶
tags:
  - CAP
  - BASE
  - 分布式
---

# 简要介绍CAP理论3进2和Base理论

## ACID原则

首先我们要知道一点，关系型数据库是要遵循ACID规则的。即：
- A (Atomicity)原子性：原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的。条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。

- C (Consistency) 一致性：一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。

- I (Isolation) 独立性：所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。

- D (Durability) 持久性：持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也
  不会丢失。

## CAP理论

但是，在分布式系统中，讲的更多的是CAP理论。CAP的证明基于异步网络，异步网络也是反映了真实网络中情况的模型。

真实的网络系统中，节点之间不可能保持完全同步，即便是时钟也不可能保持完全同步，所有的节点依靠获得的消息来进行本地计算和通讯。这个概念其实是相当强的，意味着任何超时判断也是不可能的，因为没有共同的时间标准。之后我们会扩展CAP的证明到弱一点的异步网络中，这个网络中时钟不完全一致，但是时钟运行的步调是一致的，这种系统是允许节点做超时判断的。

CAP的证明很简单，假设两个节点集{G1, G2}，由于网络分片导致G1和G2之间所有的通讯都断开了，如果不满足P，则整个网络不可用，如果在G1中写，在G2中读刚写的数据， G2中返回的值不可能G1中的写值。由于A的要求，G2一定要返回这次读请求，由于P的存在，导致C一定是不满足的。

这就充分说明，在实际的分布式存储系统中，我们最多只能实现CAP中的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们**只能在一致性和可用性之间进行权衡**。


> 分布式架构的时候必须做出取舍。 一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P是目前分布式数据库产品的方向。

CAP理论的核心是：**一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 最多只能同时较好的满足两个**。 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类：
- CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。
- CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。
- AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。

![常见数据库CAP理论的实践](https://image.studying.icu/image_1605075045457.png-zjoin.image)


## BASE理论

BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。

- 基本可用（Basically Available）
  假设系统出现了不可预知的故障，但还是能用，相比较正常的系统而言：
    - 响应时间上的损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。
    - 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。
    -
- 软状态（Soft state）
  相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。
  软状态指的是：**允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。**

- 最终一致（Eventually consistent）
  既然有软状态，又不能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，即所谓的最终一致性。而在实际工程实践中，最终一致性分为5种：

    - 因果一致性（Causal consistency）
      因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。

    - 读己之所写（Read your writes）
      读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。

    - 会话一致性（Session consistency）
      会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。

    - 单调读一致性（Monotonic read consistency）
      单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。

    - 单调写一致性（Monotonic write consistency）
      单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。


实际上，在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。并且不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。

