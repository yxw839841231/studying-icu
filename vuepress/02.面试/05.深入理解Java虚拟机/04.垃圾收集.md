---
title: 垃圾收集
date: 2021-06-30 10:18:50
permalink: /pages/c4c260/
categories:
tags:
  - 
---

程序计数器、虚拟机栈、本地方法栈3个区域随线程而生随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

垃圾回收的停顿现象：垃圾回收的任务是识别和回收垃圾进行内存清理，为了让垃圾回收期可以高效的执行，大部分情况下都会要求系统进入一个停顿状态。停顿的目的是终止所有的应用线程，只有这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一个瞬间的一致性，也有益于更好的标记垃圾对象。**因此垃圾回收时，都会产生停顿。**

## 判断对象存活

### 引用计数器法
给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

### 可达性分析算法
通过一系列的成为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象是不可用的。Java语言中GC Roots的对象包括下面几种：

1) 虚拟机栈（栈帧中的本地变量表）中引用的对象；
2) 方法区中类静态属性引用的对象；
3) 方法区中常量引用的对象；
4) 本地方法栈JNI（Native方法）引用的对象；

## 引用

1) 强引用: 就是在程序代码之中普遍存在的，类似new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象;
2) 软引用: 用来描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常;
3) 弱引用: 用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前（垃圾收集器一旦发现了只具有弱引用的对象，不管当前内存是否足够，都会回收它的内存），当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象;
4) 虚引用: 唯一目的就是能在这个对象被收集器回收时收到一个系统通知;

## Finalize方法和回收方法区

任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

- 废弃常量：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何String对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池；
- 无用的类（满足以下三个条件的类称作无用的类，可以被回收但不是一定会被回收）： 
    - 该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例；
    - 加载该类的ClassLoader已经被回收；
    - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；

## 垃圾收集算法
1) 标记-清除算法
   算法分为标记和清除两个阶段,首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。
   - 缺点一：效率问题，标记和清除两个过程的效率都不高；
   - 缺点二：空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
2) 复制算法
   将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。
   缺点：将内存缩小为了原来的一半。
   
   实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间(s0和s1)，每次使用Eden和其中一块Survivor，当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。
   s0和是s1是大小相同，并且可以互换的两块区域，此区域存活率比较低所以使用复制算法，每次进行minor GC在s0和s1之间进行对象复制。
3) 标记整理算法
   让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
4) 分代收集算法
   只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
   
   新生代回收频率很高，但每次回收耗时很短；
   而老年代回收频率很低，但耗时相对较长，所以应该尽量减少老年代的GC。
   
   在新生代中每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
   而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清除或者标记整理算法来进行回收。
5) 分区回收算法
   其主要就是将内存分为N多个小的独立空间，每个小空间都可以独立使用，这样进行细粒度的控制每次回收那些小的独立空间，而不是对整个内存进行GC，从而提高性能，并减少GC的停顿时间。

## 垃圾收集器
- 并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；
- 并发：指用户线程与垃圾收集线程同时执行(不一定是并行的，可能会交替执行)，用户程序在继续执行;
- 吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。
### Serial收集器
   主要回收新生代，使用了复制算法。这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
### Serial Old收集器
   Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法。
### ParNew收集器
   Serial收集器的多线程版本（新生代），除了使用了多线程进行收集之外，其余行为和Serial收集器一样。
### Parallel Scavenge收集器
   Parallel Scavenge收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器。
### Parallel Old 收集器
   Parallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法。
### CMS收集器
   CMS收集器是基于标记清除算法实现的，优点是并发收集、低停顿。整个过程分为4个步骤：
1) 初始标记：仅仅是标记一下GC roots能直接关联的对象，速度很快;
2) 并发标记：就是进行gc roots tracing测过程;
3) 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短;
4) 并发清除。
   
   缺点：
    1) CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量 + 3）/ 4;
    2) CMS收集器无法处理浮动垃圾，可能出现Failure而导致一次Full G产生;
    3) CMS是基于标记清除算法实现的，该算法本身效率不高;
### G1收集器
G1收集器是一款面向服务器应用的垃圾收集器，G1运作步骤：初始标记->并发标记->最终标记->筛选回收。

优点：
1) 并行于并发：G1能充分利用CPU和多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行；
2) 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果；
3) 空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于标记整理算法实现的收集器；从局部上来看是基于复制算法实现的；
4) 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但Ｇ1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内；

## 内存分配与回收策略

1) 对象优先在Eden分配：大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC； 
2) 大对象直接进入老年代：所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个 Survivor 之间发生大量的内存复制；
3) 长期存活的对象将进入老年代：如果对象在Eden区出生并且经过一次Minor GC后仍然存活，并且能够被Survivor容纳，将被移动到 Survivor 空间中，并且把对象年龄设置成为1，对象在 Survivor 区中每熬过一次Minor GC年龄就增加1岁，当它的年龄增加到一定程度(默认15岁)，就将会被晋级到老年代中;
4) 动态对象年龄判定：为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在 Survivor 空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄;
5) 空间分配担保：在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的；如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于将尝试进行一次Minor GC，尽管这次Minor GC是有风险的：如果小于或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。