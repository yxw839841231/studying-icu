---
title: JAVA 篇
date: 2021-08-09 10:54:56
permalink: /pages/d07eb5/
categories:
tags:
  - 
---


## LinkedList 和 ArrayList 的区别

- 数据结构:
  - linkedlist 是基于双向链表, 
  - arraylist 是基于数组.

- 读写性能:
  - 尾部追加无性能差异,
  - 如果中间位置插入,linkedlist 要快,arraylist 随机查找性能更快

- 扩容机制:arraylist 空间不足时,需要进行扩容.

- 空间占用:linked 空间占用要稍微大一些.

## LinkedHashMap 和 TreeMap 有序是一样的吗?

LinkedHashMap 是按照插入顺序排序

TreeMap 按照 key 的值排序

## HashMap 原理

- 计算 key 对应的 HashCode,该 HashCode 与自身右移 16 位进行异或运算,对 Hash 值进行扰动,减少 Hash 冲突
- 根据 HashCode 计算取 mod 计算该 key 所在数组中的位置(n-1)&hash,
- 如果对应的位置无元素,则新建一个节点放到该位置
- 如果该位置上存在元素,则判断该元素的类型
  - 如果是树节点,则遍历树在树中追加元素
  - 如果是非树节点则追加到链表的尾部, 
  - 如果链表超过 8 个,则转换为红黑树
- 如果 put 元素的个数,超过数组大小*负载因子的话,则进行扩容,
- 扩容的时候生成原数组大小两倍的空间,然后将原数组的元素依次拷贝到新的数组.

**采用红黑树的好处是如果 hash 冲突比较严重时,ᨀ升查询的性能.避免 hash 攻击,造成安全问题**

## ConcurrentHashMap

JDK1.7 基于 HashMap 的基础上增加了分段锁,通过减小锁的力度来提升并发能力,默认有 16 个分段锁,每个分段
锁又是一个数组+链表的结果,segment 继承了 reentrylock 实现,一个线程只能锁一个 segment.

JDK1.8 是基于 CAS+Synchronize 实现的.数据结构也是数组+链表+红黑树,当某个数组的位置为空时,采用
CAS 的乐观锁方式来进行 put 值,当数组的位置不为空时,会对节点进行锁定.

因此 JDK1.8 的锁的力度更小,相对 JDK1.7 来说并发能力更好.

## AQS 的实现

AQS 是一个抽象的 FIFO 队列同步器,维护了一个 volatile 语义的共享资源变量 state,和一个 FIFO 的线程等待队列.

例如 ReentrantLock、信号量、CountDownLatch 就是基于 AQS 实现的.

AQS 的核心思想是,如果被请求的资源空闲,则将当前请求资源的线程设置为 owner 线程,并将资源设定为锁定状态,
如果资源被占有,将线程添加到消息队列中,然后通过自旋的方式,不断尝试获取锁.

## CountDownLatch、CyclicBarrier、Semaphore

CountDownLatch:维护计数器,当计数器大于 0 时,await 的线程处于阻塞状态,当计数器为 0 时,处于 await 的线程被激活.

CyclicBarrier:多个线程在栅栏处等待,等到足够数量后,释放栅栏,栅栏可反复使用

Semaphore:计数器信号量,通过 acquire 和 release 控制并发运行的线程数


## volatile 的作用
volatile 的作用主要有两个,一个是防止指令重排序/一个是保持内存的可见性.

### 1、指令重排序

JVM 编译器会对指令进行重排序以提升并发性能.会让指令按照非程序语义的顺序执行.有编译重排序,处理器指令重排序、内存重排序

而指令重排序在多线程情况下可能存在问题,比如单例模式,多线程下可能获取未初始化的对象.
创建对象的过程
- 1.申请内存地址.
- 2.在内存地址上初始化对象
- 3.将引用指向内存地址
假设按照 1->3->2 的顺序执行.就会存在问题.我们通过增加 volatile 关键字来禁用重排序。
  
### 2、内存可见

可见性就是一个线程修改了某个变量的值,其他线程就能立即看到修改的值.

Jvm 内存模型规定了所有的变量都是存储在主存中的,每个线程还有自己的工作线程,工作线程保存了主存变量的副本,不同线程间通讯需要先同步到主存.

使用 volatile 修饰能在每次变量发生变化后,强制刷新到主存.

### 3、内存屏障

阻止屏障两侧的指令重排序；即屏障下面的代码不能跟屏障上面的代码交换执行顺序，强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。

对于 Load Barrier 来说，在指令前插入 Load Barrier，可以让 CPU 高速缓存中 j 的数据失效，强制从新从主内存加载新数据；

对于 Store Barrier 来说，在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。



## 对象的组成
- 对象头
    - 运行时数据(8 字节,Hash 码、分代年龄、锁状态标志、偏向锁的线程 ID,指向 monitor 的指针)
    - 类指针(8 字节,压缩 4 字节)
    - 数组长度(4 字节) 
- 对象体
    - 对齐填充(8 字节的整数倍)

## Wait 和 sleep 的区别

sleep 是让出 CPU 的时间片,但是并不释放他所持有的对象锁.

wait 是放弃对象锁,进入 ObjetMonitor 的 waitSet 中,notify 后重现尝试去竞争锁

## synchronize 关键字

synchronize 是解决 Java 并发问题的最常用、最简单的办法. 

### 主要作用
- 1.原子性:确保线程互斥的访问同步代码块
- 2.可见性:保证共享变量的修改能及时可见,通过 JMM 模型的,当解锁的时候,将共享变量刷新到主存,线程加锁的时候,清空工作线程的内存,从主存中重新读取变量值.(反编译可以看到在 synchronized 进入之前执行 store,即将线程内存副本同步)
- 3.有序性:解决重排序问题,即一个 unlock 先行发生于后面的对同一个锁的 lock 操作

### synchronize 的实现原理

反编译得到 java 的汇编指令,synchronized 的代码块可以发现有两个关键字,monitorenter 和 monitorexit 包围代码块.

每一个对象都是一个监视锁,当线程执行 monitorenter 时,会尝试获取监视锁的所有权,一旦线程获取到了,则 moniter 的进入数+1,同一线程再次进入的时候,进入数累加,如果其他线程进入则会阻塞,当执行 monitorexit
的时候,monitor 的进入数会-1,进入数为 0 时,释放 monitor 监控锁.

monitor 对象由对象的头部指针指向,每个 monitorObject 有几个重要属性:counter(记录重入的次数)、EntryList(阻塞状态的线程会进入该列表)、WaitSet(处于等待的线程会加入到这个列表)

## JDK6 对锁优化

### 1、自适应自旋锁 

线程的阻塞和唤醒需要从用户态到核心态的转换,频繁的阻塞和唤醒对 CPU 来说是一件负担很重的事情,因此, 为了短时间的阻塞和唤醒 CPU 是很不值得.

自旋锁是一个线程试图获取锁的时候,如果这个锁被其他线程占有,就一直在循环检测锁是否释放,但是他占用了 CPU 的处理时间,因此自旋锁只适合短时间锁获取.因此,自旋时间太长或者次数太多,会转为阻塞.

自适应自旋锁如果本次自旋成功了,下次自旋的次数会更多,虚拟机认为既然上次自旋成功了,那么此次自旋很有可能成功.反之,如果很少能自旋成功,那么下次自旋次数会减少.以免浪费处理器资源.

### 2、锁消除

如果虚拟机检测同步代码块不存在多线程竞争,则消除锁.比如在单线程下使用 HashTable 和 Vector 等.

### 3、锁粗化

如果存在多个连续的同步加锁可能造成的不必要的性能损耗,因此可以合并成一个范围更大的锁.

比如循环往 vector add 数据的时候,锁会粗化到循环外。

### 4、偏向锁
Hotspot 的作者研究发现大多数场景不存在线程竞争的，而只是由单个线程多次获得，为了让锁的代价更低引入了偏向锁.

偏向锁的通过对象头的偏向锁的线程 ID 和锁状态标志来判断对象锁是否被占用,这样设计的主要目的是减少 CAS 操作以及较少 Cache 一致性带来的开销.

## 锁升级过程

### 1、轻量级锁

相对传统重量级锁的互斥量带来的性能消耗,轻量级锁采用 CAS+自旋的方式,如果仍未获得锁,则转换为重量级锁.

在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为
“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目
前的 Mark Word 的拷贝，官方称之为 Displaced Mark Word。

这时候线程堆栈与对象头的状态如图：
拷贝对象头中的 Mark Word 复制到锁记录（Lock Record）中；
拷贝成功后，虚拟机将使用 CAS 操作尝试将锁对象的 Mark Word 更新为指向 Lock Record 的指针，并将线程栈
帧中的 Lock Record 里的 owner 指针指向 Object 的 Mark Word。

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为
“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图所示。
LockRecord(栈中存储,其中 owner 指向 marketword) MarkWord(其中 stackpointer 指向 LockRecord)

### 2、重量级锁

监视器锁对接底层操作系统中的互斥量（mutex），这种同步成本非常高，包括操作系统调用引起的内核态与用户态之间的切换、线程阻塞造成的线程切换等。

## Object 的方法
toString、 wait、 notify、 notifyAll 、hashCode 、equals、 clone 、finalize、 getClass

## 浅 clone 和深 clone
浅 clone:指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。

深 clone:不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。

## hashCode 和 equals

两个都是用来判断对象是否相等的依据.hashCode 性能较好,根据对象生成的 hashCode,直接比较判断,而 equals 相对较慢,需要有一定的逻辑判断.

重写 equals 一定要重写 hashCode,hashCode 相等不一定 equals,equals 相等一定 hashCode 相等.

HashMap、Set 等就先根据 hashCode 做判断以提升性能

## 悲观锁和乐观锁

### 悲观锁
总是假设最坏的情况,每次去拿数据的时候,都认为别人会修改.例如关系型数据库的库锁、表锁、行锁等,以及 Java 中的 synchronize 和 reentrantLock 等独占锁等.

### 乐观锁

总是假设最好的情况,每次去拿数据的时候,都认为别人不会修改.如果存在锁竞争,可使用 CAS 算法,乐观锁适用于多读的情况.Atomic 下就是乐观锁的实现.

## JVM 内存结构

- 程序计数器:线程私有,当前线程所执行字节码的行号指示器,解释器根据通过该计数器选取下一行字节码指令
- 虚拟机栈:线程私有,每个方法被执行的时候都会创建一个栈帧(局部变量表(局部变量槽)、操作数据栈、动态链接、方法的出口).
- 本地方法栈
- 堆:线程共享.存放对象实例.新生代(eden->8、survivor1->1、survivor2->1)->1、老年代->2
- 方法区(jdk7 永久代 jdk8 方法区):类信息、常量、类变量、即时编译器的缓存代码
- 直接内存:NIO 利用本机内存

## 对象创建过程
- 类加载:常量池中定位类的符号引用,并检查这个类是否被加载,如果没有加载,执行类的加载过程.
- 为对象分配空间:一般根据垃圾回收器决定使用指针碰撞的方式(serial、parView 使用复制算法,空间是连续
的)还是空闲列表(CMS-使用标记-清除算法,空间不连续)的方式分配内存. 
  
  由于在分配空间时,存在并发的情况导致线程不安全,一般有两种方式解决:CAS+重试或者 TLAB 的方式分配
- 设置对象头
- 执行构造函数

## 类加载的过程
- 加载:
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    - 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
- 连接:
- 验证:验证字节码是否符合 Class 文件的规范.
- 准备:为类变量分配空间并初始化.
- 解析:将常量池中字符引用替换为直接引用
- 初始化:静态变量的赋值和静态代码块的执行

## 反射中 Class.forName()和 ClassLoader.loadClass()的区别

**Class.forName(className)方法，内部实际调用的方法是 Class.forName(className,true,classloader);**

第 2 个 boolean 参数表示类是否需要初始化， Class.forName(className)默认是需要初始化。一旦初始化，就会触发目标对象的 static 块代码执行，static 参数也会被再次初始化。

**ClassLoader.loadClass(className)方法，内部实际调用的方法是 ClassLoader.loadClass(className,false);**

第 2 个 boolean 参数表示目标对象是否进行链接，false 表示不进行链接，由上面介绍可以，不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行。

## 类加载器&双亲委派机制

- 启动类加载器:加载 JAVA_HOME/lib 下的类
- 扩展类加载器:加载 JAVA_HOME/lib/ext 下的类
- 应用程序类加载器:加载用户类路径(ClassPath)下的类 
  
  一个类加载器收到了类加载的请求,它首先不会自己先尝试去加载这个类,而是把这个请求委派给父类加载器去完成。直到传送到顶层的启动类加载器加载.只有父加载器无法完成类加载请求,才由子类加载器完成。
  
- 作用:防止同一个类重复加载，出于安全和稳定性考虑,保证了核心的类不能被加载替换。

## 如何判断对象是否存活

- 引用计数法(无法解决循环依赖的问题)
- 可达性分析算法:
通过 GCRoot 作为起始节点,根据引用关系向下搜索,如果某个对象到 GCRoot 之间没有引用链,则这个对象可以回收。但是如果 finalize 中对 this 对象重新引用则对象就不一定可以回收。

## 哪些对象可以作为 GCRoot

- 虚拟机栈中的引用对象
- 方法区静态属性引用的对象
- 方法区常量引用的对象
- 被同步锁持有的对象等等

## 垃圾回收算法及其优缺点

- 标记清除算法：执行效率不稳定,如果大量对象需要回收需要执行大量的标记清除，存在内存碎片化问题。
- 标记复制算法
  - 优点：只需要复制存活的对象；解决了内存碎片化问题
  - 缺点：由于预留空间进行复制,造成了空间的浪费
- 标记整理算法
  - 解决了内存碎片化的问题
  - 如果存活的对象很多,处理时间变慢
- 分代垃圾回收：不同年龄代对象的存活周期不一样分代处理更有优势

## 垃圾回收器

略~

## ThreadLocal 的实现原理
当向 ThreadLocal 中 set 一个变量的时候,实际上先获取当前线程的 threadlocals,它是一个 Map 结构,key 为
ThreadLocal 对象的弱引用,Value 为设置的值.

Entry 中 key 为弱引用的目的就是当 ThreadLocal 置空时,Entry 中的 key 与 threadlocal 只剩下一弱引用,当
垃圾回收时,就可以回收 threadlocal 对象.

使用线程池存在什么问题,因为线程池每次获取的可能不是一个线程,有的时候甚至线程会消亡,有的线程可能永驻线程池,因此会导致 threadlocal 的 set 和 get 不一致,或者内存溢出等问题.

## 强软弱虚
- 强引用:垃圾回收即使报 OOM,也不会回收这种对象
- 软引用:内存空间不足时,也就是 OOM 之前,只被软引用的对象,会回收这种对象.
- 弱引用:垃圾回收器线程扫᧿它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
- 虚引用:跟没有任何引用一样,随时都有可能被回收,用来跟踪对象被垃圾回收的活动