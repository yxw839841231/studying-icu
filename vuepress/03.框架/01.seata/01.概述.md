---
title: Seata 简介
date: 2020-12-14 15:05:19
permalink: /pages/c25591/
categories:
  - 框架
  - seata
tags:
  - seata
  - 分布式事务
---
# 概述

## SEATA是什么
Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。

### AT（Automatic Transaction）模式
AT 模式是一种无侵入的分布式事务解决方案。在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。

#### AT 模式的执行流程
在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

以官网例子说明：两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。

![一阶段](https://cdn.jsdelivr.net/gh/yxw839841231/images/studying-icu/20210119170950.jpg)

第一阶段：tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的全局锁 ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 全局锁 ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 全局锁 。

注意：在全局事务中，每一条记录都有一个本地锁和一个全局锁。事务的成功提交需要本地锁和全局锁来把关。在第一阶段，不同的事务要操作同一条记录的时候需要获得这条记录的本地锁和全局锁。本地锁对数据进行ACID操作，全局锁进行commit操作。

![二阶段](https://cdn.jsdelivr.net/gh/yxw839841231/images/studying-icu/20210119170951.jpg)

第二阶段：第二阶段分为成功与失败。

- 成功的时候：全局提交，释放 全局锁 。tx2 拿到 全局锁 提交本地事务。
- 失败的时候：如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。
此时，如果 tx2 仍在等待该数据的 全局锁，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 全局锁 等锁超时，放弃 全局锁 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。
因为整个过程 全局锁 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 脏写 的问题。
成功的提交过程比较容易理解，不同的事务依次提交即可。
失败的时候：需要等待tx2释放已经拿到的本地锁，即tx2的事务提交失败，tx2的事务开始回滚。然后tx1开始执行回滚操作，tx1事务开始回滚。从而保证了数据不会出现脏读。

#### 工作机制

##### 一阶段准备


- 解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = ‘TXC’）等相关的信息。

- 查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。

```sql 
 select id, name, since from product where name = 'TXC';
```

- 执行业务 SQL：更新这条记录的 name 为 ‘GTS’。

- 查询后镜像：根据前镜像的结果，通过 主键 定位数据。

```sql 
 select id, name, since from product where id = 1;
```

- 插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。回滚日志只有在真正出现回滚的时候才会回滚。

```json
{
	"branchId": 641789253,
	"undoItems": [{
		"afterImage": {
			"rows": [{
				"fields": [{
					"name": "id",
					"type": 4,
					"value": 1
				}, {
					"name": "name",
					"type": 12,
					"value": "GTS"
				}, {
					"name": "since",
					"type": 12,
					"value": "2014"
				}]
			}],
			"tableName": "product"
		},
		"beforeImage": {
			"rows": [{
				"fields": [{
					"name": "id",
					"type": 4,
					"value": 1
				}, {
					"name": "name",
					"type": 12,
					"value": "TXC"
				}, {
					"name": "since",
					"type": 12,
					"value": "2014"
				}]
			}],
			"tableName": "product"
		},
		"sqlType": "UPDATE"
	}],
	"xid": "xid:xxx"
}

```

- 提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。
- 本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。
- 将本地事务提交的结果上报给 TC。

##### 二阶段回滚
- 收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。
- 通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。
- 数据校验：拿 UNDO LOG中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。
- 根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句

```sql
update product set name = 'TXC' where id = 1;

```
- 提交本地事务。并把本地事务的执行结果上报给 TC。

##### 二阶段-提交

- 收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。
- 异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。

### TCC 模式

区别于AT模式的自动事务机制，TCC模式更偏向手动模式。
AT 模式（参考链接 TBD）基于 支持本地 ACID 事务 的 关系型数据库：

- 一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。
- 二阶段 commit 行为：马上成功结束，自动 异步批量清理回滚日志。
- 二阶段 rollback 行为：通过回滚日志，自动 生成补偿操作，完成数据回滚。

相应的，TCC 模式，不依赖于底层数据资源的事务支持：

- 一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。
- 二阶段 commit 行为：调用 自定义 的 commit 逻辑。
- 二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。

所谓 TCC 模式，是指 **支持把 _自定义_ 的分支事务纳入到全局事务的管理中**。

### Saga 模式
Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。

![Saga模式示意图](https://cdn.jsdelivr.net/gh/yxw839841231/images/studying-icu/20210119170958.png)


#### 适用场景
- 业务流程长、业务流程多
- 参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口
#### 优势
- 一阶段提交本地事务，无锁，高性能
- 事件驱动架构，参与者可异步执行，高吞吐
- 补偿服务易于实现
#### 缺点
- 不保证隔离性（应对方案见用户文档）